<script>
/**
 * GAS フラッシュカード - クライアントサイドJavaScript
 * リファクタリング版 + ステップ8: 統計表示
 */

// ============================================
// グローバル状態
// ============================================
const AppState = {
  // データ
  fields: [],
  cards: [],
  progress: {},
  settings: {},
  decks: { tree: {}, list: [] },
  
  // アプリ状態
  isLoading: true,
  error: null,
  selectedDeck: null,
  todayStudyCount: 0,
  editingCard: null,
  
  // 学習状態
  study: {
    mode: null,
    cards: [],
    currentIndex: 0,
    isFlipped: false,
    sessionAnswers: {},
    isSpeaking: false,
    isAutoPlay: false,
    isRepeat: false
  }
};

// スプレッドシートURL
const SPREADSHEET_URL = 'https://docs.google.com/spreadsheets/d/1i5YCfwU_IJYC-4EWZQsBxIOVczdrJShvInJZGPxmZ0U/';

// ============================================
// 定数
// ============================================
const ANIMATION_DURATION = {
  SLIDE: 400,
  FLIP: 600,
  FEEDBACK: 500
};

const DEFAULT_SETTINGS = {
  speechRateEn: 1.0,
  speechRateJa: 1.0,
  listSpeechRateEn: 1.0,
  listSpeechRateJa: 1.0,
  waitTimeAfterFlip: 0,
  waitTimeBetweenCards: 0,
  interval_1: 1,
  interval_2: 3,
  interval_3: 7,
  interval_4: 14,
  interval_5: 30
};

// ============================================
// ユーティリティ関数
// ============================================
const Utils = {
  escapeHtml: function(str) {
    if (str === null || str === undefined) return '';
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  },

  shuffleArray: function(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  },

  getTodayString: function() {
    return new Date().toISOString().split('T')[0];
  },

  getDateAfterDays: function(days) {
    const date = new Date();
    date.setDate(date.getDate() + days);
    return date.toISOString().split('T')[0];
  },

  getSettingNumber: function(key, defaultValue) {
    const value = parseFloat(AppState.settings[key]);
    return isNaN(value) ? defaultValue : value;
  },

  setElementText: function(id, text) {
    const el = document.getElementById(id);
    if (el) el.textContent = text;
  }
};

// ============================================
// 統計計算モジュール
// ============================================
const Stats = {
  calculate: function() {
    const cards = AppState.cards;
    const progress = AppState.progress;
    const today = Utils.getTodayString();
    
    let studied = 0, passed = 0, review = 0;
    let totalCorrect = 0, totalIncorrect = 0;
    
    for (const card of cards) {
      const prog = progress[card.rowNumber];
      if (!prog) continue;
      
      if (prog.correctCount > 0 || prog.incorrectCount > 0) studied++;
      if (prog.passed) passed++;
      if (prog.nextReviewDate && prog.nextReviewDate <= today && !prog.passed) review++;
      totalCorrect += prog.correctCount || 0;
      totalIncorrect += prog.incorrectCount || 0;
    }
    
    const totalAnswers = totalCorrect + totalIncorrect;
    const accuracy = totalAnswers > 0 ? Math.round((totalCorrect / totalAnswers) * 100) : 0;
    
    return { total: cards.length, studied, passed, review, totalCorrect, totalIncorrect, accuracy };
  },

  updateHomeStats: function() {
    const stats = this.calculate();
    Utils.setElementText('stat-today', AppState.todayStudyCount);
    Utils.setElementText('stat-total', stats.studied + ' / ' + stats.total);
    Utils.setElementText('stat-passed', stats.passed);
    Utils.setElementText('stat-review', stats.review);
    // 今日のテストボタンに残り枚数を表示
    const badge = document.getElementById('review-count-badge');
    if (badge) badge.textContent = stats.review;
  }
};

// ============================================
// 読み上げモジュール
// ============================================
const Speech = {
  // 現在読み上げ中のカードRowNumber（一覧用）
  currentListRowNumber: null,

  detectLanguage: function(fieldName, text) {
    const lowerName = fieldName.toLowerCase();
    if (lowerName.includes('英語') || lowerName.includes('english') || lowerName === 'en') return 'en-US';
    if (lowerName.includes('日本語') || lowerName.includes('japanese') || lowerName === 'ja' || 
        lowerName.includes('読み') || lowerName.includes('例文')) return 'ja-JP';
    if (text && /[぀-ゟ゠-ヿ一-龯]/.test(text)) return 'ja-JP';
    return 'en-US';
  },

  speak: function(text, lang, onEnd, useListRate) {
    if (!('speechSynthesis' in window)) { if (onEnd) onEnd(); return; }
    
    window.speechSynthesis.cancel();
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = lang;
    
    // 一覧表示用の読み上げ速度を使用するかどうか
    let rateKey;
    if (useListRate) {
      rateKey = lang === 'en-US' ? 'listSpeechRateEn' : 'listSpeechRateJa';
    } else {
      rateKey = lang === 'en-US' ? 'speechRateEn' : 'speechRateJa';
    }
    utterance.rate = Math.max(0.1, Math.min(10, Utils.getSettingNumber(rateKey, DEFAULT_SETTINGS[rateKey])));
    
    console.log('Speaking:', text, 'lang:', lang, 'rate:', utterance.rate, 'useListRate:', useListRate);
    App.setSpeakingState(true);
    
    utterance.onend = () => { 
      App.setSpeakingState(false);
      this.currentListRowNumber = null;
      App.updateListSpeakingState(null);
      if (onEnd) onEnd(); 
    };
    utterance.onerror = (e) => {
      if (e.error !== 'interrupted') console.error('Speech error:', e);
      App.setSpeakingState(false);
      this.currentListRowNumber = null;
      App.updateListSpeakingState(null);
      if (e.error !== 'interrupted' && onEnd) onEnd();
    };
    
    window.speechSynthesis.speak(utterance);
  },

  speakSequence: function(items, index, onComplete, useListRate) {
    if (index >= items.length) {
      App.setSpeakingState(false);
      this.currentListRowNumber = null;
      App.updateListSpeakingState(null);
      if (onComplete) onComplete();
      return;
    }
    const item = items[index];
    this.speak(item.text, item.lang, () => this.speakSequence(items, index + 1, onComplete, useListRate), useListRate);
  },

  stop: function() {
    if ('speechSynthesis' in window) window.speechSynthesis.cancel();
    App.setSpeakingState(false);
    this.currentListRowNumber = null;
    App.updateListSpeakingState(null);
  }
};

// ============================================
// カード描画モジュール
// ============================================
const CardRenderer = {
  getFieldsBySide: function(side) {
    return AppState.fields
      .filter(f => f.displaySide === side)
      .sort((a, b) => (parseInt(a.displayOrder) || 99) - (parseInt(b.displayOrder) || 99));
  },

  // 一覧表示用：listSide/listOrderを使用
  getFieldsByListSide: function(side) {
    return AppState.fields
      .filter(f => f.listSide === side)
      .sort((a, b) => (parseInt(a.listOrder) || 99) - (parseInt(b.listOrder) || 99));
  },

  renderFields: function(card, fields) {
    return fields.map((field, index) => {
      const value = card.fields[field.name] || '';
      const isFirst = index === 0;
      return '<div class="card-field"><div class="card-field-label">' + Utils.escapeHtml(field.name) + 
        '</div><div class="card-field-value' + (isFirst ? ' large' : '') + '">' + Utils.escapeHtml(value) + '</div></div>';
    }).join('');
  },

  render: function(card) {
    if (!card) return;
    document.getElementById('front-content').innerHTML = this.renderFields(card, this.getFieldsBySide('表'));
    document.getElementById('back-content').innerHTML = this.renderFields(card, this.getFieldsBySide('裏'));
  },

  renderNext: function(nextCard) {
    const nextEl = document.getElementById('flashcard-next');
    if (!nextCard) { nextEl.style.visibility = 'hidden'; return; }
    nextEl.style.visibility = 'visible';
    document.getElementById('next-front-content').innerHTML = this.renderFields(nextCard, this.getFieldsBySide('表'));
  }
};

// ============================================
// アプリケーションメイン
// ============================================
const App = {
  init: function() {
    console.log('App initializing...');
    this.loadInitialData();
  },

  loadInitialData: function() {
    this.showScreen('loading-screen');
    google.script.run
      .withSuccessHandler(this.onDataLoaded.bind(this))
      .withFailureHandler(this.onDataError.bind(this))
      .getInitialData();
  },

  onDataLoaded: function(data) {
    try {
      AppState.fields = data.fields || [];
      AppState.cards = data.cards || [];
      AppState.progress = data.progress || {};
      AppState.settings = data.settings || {};
      AppState.decks = data.decks || { tree: {}, list: [] };
      AppState.isLoading = false;
      
      Stats.updateHomeStats();
      this.updateDebugInfo();
      this.showScreen('home-screen');
    } catch (error) {
      console.error('Error in onDataLoaded:', error);
    }
  },

  onDataError: function(error) {
    console.error('Data load error:', error);
    AppState.error = error;
    AppState.isLoading = false;
    document.getElementById('error-message').textContent = error.message || 'データの読み込みに失敗しました';
    this.showScreen('error-screen');
  },

  retry: function() { this.loadInitialData(); },

  showScreen: function(screenId) {
    document.querySelectorAll('.screen').forEach(s => { s.classList.remove('active'); s.style.display = 'none'; });
    const target = document.getElementById(screenId);
    if (target) {
      target.classList.add('active');
      target.style.display = screenId === 'loading-screen' ? 'flex' : 'block';
    }
  },

  updateDebugInfo: function() {
    Utils.setElementText('debug-connection', '✓ 接続成功');
    const conn = document.getElementById('debug-connection');
    if (conn) conn.style.color = 'green';
    Utils.setElementText('debug-card-count', AppState.cards.length);
    Utils.setElementText('debug-field-count', AppState.fields.length);
    Utils.setElementText('debug-deck-count', AppState.decks.list.length);
  },

  showRawData: function() {
    const el = document.getElementById('debug-raw-data');
    if (el.classList.contains('show')) { el.classList.remove('show'); }
    else {
      el.textContent = JSON.stringify({ fields: AppState.fields, cards: AppState.cards, progress: AppState.progress, settings: AppState.settings, decks: AppState.decks }, null, 2);
      el.classList.add('show');
    }
  },

  // 学習開始
  startStudy: function(mode) {
    const today = Utils.getTodayString();
    let cards = [];
    
    if (mode === 'review') {
      cards = AppState.cards.filter(c => {
        const p = AppState.progress[c.rowNumber];
        return p && p.nextReviewDate && p.nextReviewDate <= today && !p.passed;
      });
    } else if (mode === 'new') {
      cards = AppState.cards.filter(c => {
        const p = AppState.progress[c.rowNumber];
        return !p || (p.correctCount === 0 && p.incorrectCount === 0);
      });
    } else {
      cards = [...AppState.cards];
    }
    
    if (cards.length === 0) { alert('学習するカードがありません'); return; }
    if (AppState.settings.shuffleCards !== false) cards = Utils.shuffleArray(cards);
    this.initStudySession(mode, cards);
  },

  startFilteredStudy: function() {
    const shuffle = document.getElementById('setting-shuffle').checked;
    let cards = this.getFilteredCards();
    if (cards.length === 0) { alert('条件に一致するカードがありません'); return; }
    if (shuffle) cards = Utils.shuffleArray(cards);
    this.initStudySession('filtered', cards);
  },

  initStudySession: function(mode, cards) {
    AppState.study = { mode, cards, currentIndex: 0, isFlipped: false, sessionAnswers: {}, isSpeaking: false, isAutoPlay: false, isRepeat: false };
    this.showScreen('study-screen');
    this.renderCard();
    this.updateStudyProgress();
  },

  // カード表示
  renderCard: function() {
    Speech.stop();
    const card = AppState.study.cards[AppState.study.currentIndex];
    if (!card) return;
    
    CardRenderer.render(card);
    const flashcard = document.getElementById('flashcard');
    flashcard.classList.remove('flipped');
    AppState.study.isFlipped = false;
    document.getElementById('answer-buttons').style.display = 'flex';
    this.updateCardButtons(card);
    this.updateNavButtons();
    this.prepareNextCard();
  },

  updateCardContent: function() {
    const card = AppState.study.cards[AppState.study.currentIndex];
    if (!card) return;
    CardRenderer.render(card);
    document.getElementById('answer-buttons').style.display = 'flex';
    this.updateCardButtons(card);
    this.updateNavButtons();
  },

  prepareNextCard: function() {
    const next = AppState.study.currentIndex + 1;
    CardRenderer.renderNext(next < AppState.study.cards.length ? AppState.study.cards[next] : null);
  },

  flipCard: function() {
    AppState.study.isFlipped = !AppState.study.isFlipped;
    document.getElementById('flashcard').classList.toggle('flipped', AppState.study.isFlipped);
  },

  updateStudyProgress: function() {
    Utils.setElementText('study-current', AppState.study.currentIndex + 1);
    Utils.setElementText('study-total', AppState.study.cards.length);
  },

  updateCardButtons: function(card) {
    const prog = AppState.progress[card.rowNumber] || {};
    const fav = document.getElementById('btn-favorite');
    const pass = document.getElementById('btn-passed');
    fav.classList.toggle('active', prog.favorite);
    fav.querySelector('.material-icons').textContent = prog.favorite ? 'star' : 'star_border';
    pass.classList.toggle('passed', prog.passed);
    pass.querySelector('.material-icons').textContent = prog.passed ? 'check_circle' : 'check_circle_outline';
  },

  updateNavButtons: function() {
    document.getElementById('btn-prev').disabled = AppState.study.currentIndex === 0;
    document.getElementById('btn-next').disabled = AppState.study.currentIndex >= AppState.study.cards.length - 1;
  },

  prevCard: function() { if (AppState.study.currentIndex > 0) this.slideToCard(AppState.study.currentIndex - 1, 'prev'); },
  
  nextCard: function() {
    if (AppState.study.currentIndex < AppState.study.cards.length - 1) this.slideToCard(AppState.study.currentIndex + 1, 'next');
    else this.finishStudy();
  },

  slideToCard: function(newIndex, direction) {
    const flashcard = document.getElementById('flashcard');
    const inner = flashcard.querySelector('.flashcard-inner');
    
    Speech.stop();
    CardRenderer.renderNext(AppState.study.cards[newIndex]);
    flashcard.classList.add(direction === 'next' ? 'slide-out-left' : 'slide-out-right');
    
    setTimeout(() => {
      AppState.study.currentIndex = newIndex;
      flashcard.style.transition = 'none';
      inner.style.transition = 'none';
      flashcard.classList.remove('slide-out-left', 'slide-out-right', 'flipped');
      AppState.study.isFlipped = false;
      this.updateCardContent();
      flashcard.offsetHeight;
      flashcard.style.transition = '';
      inner.style.transition = '';
      this.prepareNextCard();
      this.updateStudyProgress();
    }, ANIMATION_DURATION.SLIDE);
  },

  // 回答処理
  answerCard: function(isCorrect) {
    const card = AppState.study.cards[AppState.study.currentIndex];
    const row = card.rowNumber;
    let prog = AppState.progress[row] || { correctCount: 0, incorrectCount: 0, streak: 0, nextReviewDate: null, favorite: false, passed: false };
    
    const prev = AppState.study.sessionAnswers[row];
    if (prev) {
      if (prev === 'correct') { prog.correctCount = Math.max(0, prog.correctCount - 1); prog.streak = Math.max(0, prog.streak - 1); }
      else { prog.incorrectCount = Math.max(0, prog.incorrectCount - 1); }
    }
    
    if (isCorrect) { prog.correctCount++; prog.streak++; }
    else { prog.incorrectCount++; prog.streak = 0; }
    
    // 新規回答の場合のみ今日の学習数をカウント
    if (!prev) {
      AppState.todayStudyCount++;
    }
    AppState.study.sessionAnswers[row] = isCorrect ? 'correct' : 'incorrect';
    prog.nextReviewDate = this.calculateNextReviewDate(prog.streak);
    AppState.progress[row] = prog;
    this.saveProgressToServer(row, prog);
    
    const flashcard = document.getElementById('flashcard');
    const anim = isCorrect ? 'answer-correct' : 'answer-incorrect';
    flashcard.classList.add(anim);
    
    setTimeout(() => {
      flashcard.classList.remove(anim);
      if (AppState.study.currentIndex < AppState.study.cards.length - 1) this.slideToCard(AppState.study.currentIndex + 1, 'next');
      else this.finishStudy();
    }, ANIMATION_DURATION.FEEDBACK);
  },

  calculateNextReviewDate: function(streak) {
    const intervals = [[5, 'interval_5'], [4, 'interval_4'], [3, 'interval_3'], [2, 'interval_2'], [1, 'interval_1']];
    for (const [min, key] of intervals) {
      if (streak >= min) return Utils.getDateAfterDays(Utils.getSettingNumber(key, DEFAULT_SETTINGS[key]));
    }
    return Utils.getDateAfterDays(1);
  },

  saveProgressToServer: function(row, data) {
    google.script.run.withSuccessHandler(() => console.log('Progress saved')).withFailureHandler(e => console.error('Failed:', e)).saveProgress(row, data);
  },

  toggleFavorite: function() {
    const card = AppState.study.cards[AppState.study.currentIndex];
    let prog = AppState.progress[card.rowNumber] || { correctCount: 0, incorrectCount: 0, streak: 0, nextReviewDate: null, favorite: false, passed: false };
    prog.favorite = !prog.favorite;
    AppState.progress[card.rowNumber] = prog;
    this.updateCardButtons(card);
    this.saveProgressToServer(card.rowNumber, prog);
  },

  togglePassed: function() {
    const card = AppState.study.cards[AppState.study.currentIndex];
    let prog = AppState.progress[card.rowNumber] || { correctCount: 0, incorrectCount: 0, streak: 0, nextReviewDate: null, favorite: false, passed: false };
    prog.passed = !prog.passed;
    AppState.progress[card.rowNumber] = prog;
    this.updateCardButtons(card);
    this.saveProgressToServer(card.rowNumber, prog);
  },

  finishStudy: function() { alert('学習完了！'); this.exitStudy(); },

  exitStudy: function() {
    Speech.stop();
    AppState.study = { mode: null, cards: [], currentIndex: 0, isFlipped: false, sessionAnswers: {}, isSpeaking: false, isAutoPlay: false, isRepeat: false };
    Stats.updateHomeStats();
    this.showScreen('home-screen');
  },

  // デッキ選択（学習設定画面内）
  renderDeckTreeInline: function() {
    const container = document.getElementById('deck-tree-inline');
    if (!container) return;
    const allSel = AppState.selectedDeck === null;
    let html = '<div class="deck-item deck-all-item' + (allSel ? ' selected' : '') + '" onclick="App.selectDeckInline(null)">' +
      '<span class="material-icons">folder_special</span><span class="deck-item-name">すべてのデッキ</span>' +
      '<span class="deck-item-count">' + AppState.cards.length + '枚</span></div>';
    html += this.renderDeckTreeNode(AppState.decks.tree, '');
    container.innerHTML = html;
  },

  selectDeckInline: function(path) {
    AppState.selectedDeck = path;
    this.renderDeckTreeInline();
    this.updateFilteredCardCount();
  },

  toggleSection: function(header) {
    const content = header.nextElementSibling;
    const icon = header.querySelector('.collapse-icon');
    if (content.style.maxHeight) {
      content.style.maxHeight = null;
      icon.textContent = 'expand_more';
    } else {
      content.style.maxHeight = content.scrollHeight + 'px';
      icon.textContent = 'expand_less';
    }
  },

  // デッキ選択（旧画面 - 互換性のため残す）
  showDeckSelect: function() { this.showStudySettings(); },
  closeDeckSelect: function() { this.showScreen('home-screen'); },

  renderDeckTree: function() {
    const container = document.getElementById('deck-tree');
    const allSel = AppState.selectedDeck === null;
    let html = '<div class="deck-item deck-all-item' + (allSel ? ' selected' : '') + '" onclick="App.selectDeck(null)">' +
      '<span class="material-icons">folder_special</span><span class="deck-item-name">すべてのデッキ</span>' +
      '<span class="deck-item-count">' + AppState.cards.length + '枚</span></div>';
    html += this.renderDeckTreeNode(AppState.decks.tree, '');
    container.innerHTML = html;
  },

  renderDeckTreeNode: function(node, parentPath) {
    let html = '';
    for (const key in node) {
      if (key === '_path' || key === '_children') continue;
      const path = parentPath ? parentPath + '/' + key : key;
      const children = node[key]._children || {};
      const childKeys = Object.keys(children).filter(k => k !== '_path' && k !== '_children');
      const hasChildren = childKeys.length > 0;
      const count = this.getCardCountForDeck(path);
      const sel = AppState.selectedDeck === path;
      
      html += '<div class="deck-node"><div class="deck-item' + (sel ? ' selected' : '') + '" onclick="App.selectDeckInline(\'' + Utils.escapeHtml(path) + '\')">';
      if (hasChildren) html += '<button class="deck-toggle" onclick="event.stopPropagation(); App.toggleDeckNode(this)"><span class="material-icons">chevron_right</span></button>';
      else html += '<span style="width: 28px; display: inline-block;"></span>';
      html += '<span class="material-icons">folder</span><span class="deck-item-name">' + Utils.escapeHtml(key) + '</span><span class="deck-item-count">' + count + '枚</span></div>';
      if (hasChildren) html += '<div class="deck-children" style="display: none;">' + this.renderDeckTreeNode(children, path) + '</div>';
      html += '</div>';
    }
    return html;
  },

  getCardCountForDeck: function(path) {
    return AppState.cards.filter(c => { const d = c.fields['デッキ'] || ''; return d === path || d.startsWith(path + '/'); }).length;
  },

  toggleDeckNode: function(btn) {
    const node = btn.closest('.deck-node');
    const children = node.querySelector('.deck-children');
    if (children) { const hidden = children.style.display === 'none'; children.style.display = hidden ? 'block' : 'none'; btn.classList.toggle('expanded', hidden); }
  },

  selectDeck: function(path) { AppState.selectedDeck = path; this.renderDeckTreeInline(); this.updateFilteredCardCount(); },

  updateSelectedDeckInfo: function() {
    // 互換性のため残す（学習設定画面に統合されたため不要）
  },

  // 学習設定
  showStudySettings: function() {
    document.getElementById('word-start').value = '';
    document.getElementById('word-count').value = '';
    document.getElementById('filter-favorite').checked = false;
    document.getElementById('filter-not-passed').checked = false;
    document.getElementById('setting-shuffle').checked = true;
    document.querySelector('input[name="studyMode"][value="all"]').checked = true;
    this.renderDeckTreeInline();
    this.setupStudySettingsListeners();
    this.updateFilteredCardCount();
    this.showScreen('study-settings-screen');
  },

  setupStudySettingsListeners: function() {
    const handler = this.updateFilteredCardCount.bind(this);
    ['word-start', 'word-count', 'filter-favorite', 'filter-not-passed', 'setting-shuffle'].forEach(id => {
      const el = document.getElementById(id);
      el.removeEventListener('change', handler); el.addEventListener('change', handler);
      if (el.type === 'number') { el.removeEventListener('input', handler); el.addEventListener('input', handler); }
    });
    document.querySelectorAll('input[name="studyMode"]').forEach(r => { r.removeEventListener('change', handler); r.addEventListener('change', handler); });
  },

  updateFilteredCardCount: function() { document.getElementById('filtered-card-count').textContent = this.getFilteredCards().length; },

  getFilteredCards: function() {
    const mode = document.querySelector('input[name="studyMode"]:checked').value;
    const start = parseInt(document.getElementById('word-start').value) || null;
    const count = parseInt(document.getElementById('word-count').value) || null;
    const fav = document.getElementById('filter-favorite').checked;
    const notPass = document.getElementById('filter-not-passed').checked;
    const today = Utils.getTodayString();
    
    let cards = [...AppState.cards];
    if (AppState.selectedDeck !== null) cards = cards.filter(c => { const d = c.fields['デッキ'] || ''; return d === AppState.selectedDeck || d.startsWith(AppState.selectedDeck + '/'); });
    cards.sort((a, b) => a.rowNumber - b.rowNumber);
    
    if (start !== null && start >= 1) { const idx = start - 1; cards = count !== null && count >= 1 ? cards.slice(idx, idx + count) : cards.slice(idx); }
    else if (count !== null && count >= 1) cards = cards.slice(0, count);
    
    if (mode === 'review') cards = cards.filter(c => { const p = AppState.progress[c.rowNumber]; return p && p.nextReviewDate && p.nextReviewDate <= today && !p.passed; });
    else if (mode === 'new') cards = cards.filter(c => { const p = AppState.progress[c.rowNumber]; return !p || (p.correctCount === 0 && p.incorrectCount === 0); });
    
    if (fav) cards = cards.filter(c => { const p = AppState.progress[c.rowNumber]; return p && p.favorite; });
    if (notPass) cards = cards.filter(c => { const p = AppState.progress[c.rowNumber]; return !p || !p.passed; });
    
    return cards;
  },

  closeStudySettings: function() { this.showScreen('home-screen'); },

  // カード一覧
  showCardList: function() {
    this.populateDeckFilter();
    this.renderCardList();
    this.showScreen('card-list-screen');
  },

  closeCardList: function() { this.showScreen('home-screen'); },

  populateDeckFilter: function() {
    const select = document.getElementById('card-list-deck-filter');
    let html = '<option value="">すべてのデッキ</option>';
    AppState.decks.list.forEach(deck => {
      html += '<option value="' + Utils.escapeHtml(deck) + '">' + Utils.escapeHtml(deck) + '</option>';
    });
    select.innerHTML = html;
  },

  filterCardList: function() { this.renderCardList(); },

  renderCardList: function() {
    const container = document.getElementById('card-list-container');
    const searchTerm = (document.getElementById('card-search').value || '').toLowerCase();
    const deckFilter = document.getElementById('card-list-deck-filter').value;
    const sideFilter = document.getElementById('card-list-side-filter').value;
    const favFilter = document.getElementById('card-list-fav-filter').value;
    const passFilter = document.getElementById('card-list-pass-filter').value;
    
    let cards = [...AppState.cards];
    
    // デッキフィルター
    if (deckFilter) {
      cards = cards.filter(c => {
        const d = c.fields['デッキ'] || '';
        return d === deckFilter || d.startsWith(deckFilter + '/');
      });
    }
    
    // お気に入りフィルター
    if (favFilter === 'fav') {
      cards = cards.filter(c => {
        const p = AppState.progress[c.rowNumber];
        return p && p.favorite;
      });
    } else if (favFilter === 'not-fav') {
      cards = cards.filter(c => {
        const p = AppState.progress[c.rowNumber];
        return !p || !p.favorite;
      });
    }
    
    // 合格フィルター
    if (passFilter === 'passed') {
      cards = cards.filter(c => {
        const p = AppState.progress[c.rowNumber];
        return p && p.passed;
      });
    } else if (passFilter === 'not-passed') {
      cards = cards.filter(c => {
        const p = AppState.progress[c.rowNumber];
        return !p || !p.passed;
      });
    }
    
    // 検索フィルター
    if (searchTerm) {
      cards = cards.filter(c => {
        for (const key in c.fields) {
          if ((c.fields[key] || '').toLowerCase().includes(searchTerm)) return true;
        }
        return false;
      });
    }
    
    // 一覧表示用のフィールドを取得（listSide/listOrderを使用）
    const leftFields = CardRenderer.getFieldsByListSide('左');
    const rightFields = CardRenderer.getFieldsByListSide('右');
    
    // 表示モードに応じたクラスを決定
    let itemClass = 'card-list-item';
    if (sideFilter === 'front') itemClass += ' left-only';
    else if (sideFilter === 'back') itemClass += ' right-only';
    
    let html = '';
    cards.forEach(card => {
      const prog = AppState.progress[card.rowNumber] || {};
      const deck = card.fields['デッキ'] || '';
      const rowNum = card.rowNumber;
      
      // 左側フィールド（クリックで読み上げ）
      let leftHtml = '<div class="card-list-left" data-row="' + rowNum + '" onclick="App.speakCardInList(' + rowNum + ', event)">';
      leftFields.forEach((field, i) => {
        const val = card.fields[field.name] || '';
        const cls = i === 0 ? 'field-main' : 'field-sub';
        leftHtml += '<div class="' + cls + '">' + Utils.escapeHtml(val) + '</div>';
      });
      leftHtml += '</div>';
      
      // 右側フィールド
      let rightHtml = '<div class="card-list-right">';
      rightFields.forEach((field, i) => {
        const val = card.fields[field.name] || '';
        const cls = i === 0 ? 'field-main' : 'field-sub';
        rightHtml += '<div class="' + cls + '">' + Utils.escapeHtml(val) + '</div>';
      });
      // デッキ名
      if (deck) rightHtml += '<div class="deck-name">' + Utils.escapeHtml(deck) + '</div>';
      rightHtml += '</div>';
      
      // アクションボタン
      let actionsHtml = '<div class="card-list-actions">';
      actionsHtml += '<button class="action-btn' + (prog.favorite ? ' favorite-active' : '') + '" onclick="App.toggleListFavorite(' + rowNum + ', event)" title="お気に入り"><span class="material-icons">' + (prog.favorite ? 'star' : 'star_border') + '</span></button>';
      actionsHtml += '<button class="action-btn' + (prog.passed ? ' passed-active' : '') + '" onclick="App.toggleListPassed(' + rowNum + ', event)" title="合格"><span class="material-icons">' + (prog.passed ? 'check_circle' : 'check_circle_outline') + '</span></button>';
      actionsHtml += '<button class="action-btn edit-btn" onclick="App.showCardEdit(' + rowNum + ', event)" title="編集"><span class="material-icons">edit</span></button>';
      actionsHtml += '</div>';
      
      html += '<div class="' + itemClass + '" data-row="' + rowNum + '">';
      html += leftHtml + rightHtml + actionsHtml;
      html += '</div>';
    });
    
    if (cards.length === 0) {
      html = '<div class="card-list-empty"><span class="material-icons">search_off</span><p>カードが見つかりません</p></div>';
    }
    
    container.innerHTML = html;
  },

  // 一覧からカードを読み上げ
  speakCardInList: function(rowNumber, event) {
    if (event) event.stopPropagation();
    
    // 既に同じカードを読み上げ中なら停止
    if (Speech.currentListRowNumber === rowNumber) {
      Speech.stop();
      return;
    }
    
    const card = AppState.cards.find(c => c.rowNumber === rowNumber);
    if (!card) return;
    
    // 読み上げ対象フィールドを取得（listSpeechOrder使用）
    const fields = AppState.fields
      .filter(f => f.listSpeechOrder && f.listSpeechOrder !== '-' && f.listSpeechOrder !== '')
      .sort((a, b) => (parseInt(a.listSpeechOrder) || 99) - (parseInt(b.listSpeechOrder) || 99));
    
    if (fields.length === 0) return;
    
    const items = fields.map(f => ({
      text: card.fields[f.name] || '',
      lang: Speech.detectLanguage(f.name, card.fields[f.name])
    })).filter(i => i.text);
    
    if (items.length === 0) return;
    
    Speech.currentListRowNumber = rowNumber;
    this.updateListSpeakingState(rowNumber);
    Speech.speakSequence(items, 0, null, true); // useListRate = true
  },

  // 一覧の読み上げ状態を更新
  updateListSpeakingState: function(rowNumber) {
    // 全ての左側要素からspeakingクラスを削除
    document.querySelectorAll('.card-list-left').forEach(el => {
      el.classList.remove('speaking');
    });
    // 読み上げ中のカードにspeakingクラスを追加
    if (rowNumber) {
      const el = document.querySelector('.card-list-left[data-row="' + rowNumber + '"]');
      if (el) el.classList.add('speaking');
    }
  },

  // 一覧からお気に入りをトグル
  toggleListFavorite: function(rowNumber, event) {
    if (event) event.stopPropagation();
    
    let prog = AppState.progress[rowNumber] || { correctCount: 0, incorrectCount: 0, streak: 0, nextReviewDate: null, favorite: false, passed: false };
    prog.favorite = !prog.favorite;
    AppState.progress[rowNumber] = prog;
    
    // UIを更新
    const item = document.querySelector('.card-list-item[data-row="' + rowNumber + '"]');
    if (item) {
      const btn = item.querySelector('.action-btn:first-child');
      if (btn) {
        btn.classList.toggle('favorite-active', prog.favorite);
        btn.querySelector('.material-icons').textContent = prog.favorite ? 'star' : 'star_border';
      }
    }
    
    this.saveProgressToServer(rowNumber, prog);
  },

  // 一覧から合格をトグル
  toggleListPassed: function(rowNumber, event) {
    if (event) event.stopPropagation();
    
    let prog = AppState.progress[rowNumber] || { correctCount: 0, incorrectCount: 0, streak: 0, nextReviewDate: null, favorite: false, passed: false };
    prog.passed = !prog.passed;
    AppState.progress[rowNumber] = prog;
    
    // UIを更新
    const item = document.querySelector('.card-list-item[data-row="' + rowNumber + '"]');
    if (item) {
      const btn = item.querySelectorAll('.action-btn')[1];
      if (btn) {
        btn.classList.toggle('passed-active', prog.passed);
        btn.querySelector('.material-icons').textContent = prog.passed ? 'check_circle' : 'check_circle_outline';
      }
    }
    
    this.saveProgressToServer(rowNumber, prog);
    Stats.updateHomeStats();
  },

  // カード編集
  showCardEdit: function(rowNumber, event) {
    if (event) event.stopPropagation();
    
    const card = AppState.cards.find(c => c.rowNumber === rowNumber);
    if (!card) return;
    
    AppState.editingCard = card;
    document.getElementById('card-edit-title').textContent = 'カード #' + (rowNumber - 7);
    
    const container = document.getElementById('card-edit-content');
    let html = '';
    
    AppState.fields.forEach(field => {
      const value = card.fields[field.name] || '';
      const side = field.displaySide === '表' ? '表面' : (field.displaySide === '裏' ? '裏面' : '');
      
      html += '<div class="card-edit-field">';
      html += '<label>' + Utils.escapeHtml(field.name);
      if (side) html += ' <span class="field-side">(' + side + ')</span>';
      html += '</label>';
      html += '<textarea id="edit-field-' + Utils.escapeHtml(field.name) + '" data-field="' + Utils.escapeHtml(field.name) + '">' + Utils.escapeHtml(value) + '</textarea>';
      html += '</div>';
    });
    
    // 進捗情報表示
    const prog = AppState.progress[rowNumber] || {};
    html += '<div class="card-edit-progress">';
    html += '<h3>学習進捗</h3>';
    html += '<div class="progress-stats">';
    html += '<span>正解: ' + (prog.correctCount || 0) + '</span>';
    html += '<span>不正解: ' + (prog.incorrectCount || 0) + '</span>';
    html += '<span>連続正解: ' + (prog.streak || 0) + '</span>';
    html += '</div>';
    html += '<div class="progress-toggles">';
    html += '<label class="checkbox-item"><input type="checkbox" id="edit-favorite" ' + (prog.favorite ? 'checked' : '') + '><span class="checkbox-label"><span class="material-icons">star</span>お気に入り</span></label>';
    html += '<label class="checkbox-item"><input type="checkbox" id="edit-passed" ' + (prog.passed ? 'checked' : '') + '><span class="checkbox-label"><span class="material-icons">check_circle</span>合格</span></label>';
    html += '</div></div>';
    
    container.innerHTML = html;
    this.showScreen('card-edit-screen');
  },

  closeCardEdit: function() {
    AppState.editingCard = null;
    this.showScreen('card-list-screen');
  },

  saveCard: function() {
    if (!AppState.editingCard) return;
    
    const card = AppState.editingCard;
    const rowNumber = card.rowNumber;
    
    // フィールド値を収集
    const updatedFields = {};
    AppState.fields.forEach(field => {
      const textarea = document.getElementById('edit-field-' + field.name);
      if (textarea) {
        updatedFields[field.name] = textarea.value;
      }
    });
    
    // 進捗情報を更新
    let prog = AppState.progress[rowNumber] || { correctCount: 0, incorrectCount: 0, streak: 0, nextReviewDate: null, favorite: false, passed: false };
    prog.favorite = document.getElementById('edit-favorite').checked;
    prog.passed = document.getElementById('edit-passed').checked;
    
    // ローカル状態を更新
    card.fields = { ...card.fields, ...updatedFields };
    AppState.progress[rowNumber] = prog;
    
    // サーバーに保存
    google.script.run
      .withSuccessHandler(() => {
        console.log('Card saved');
        alert('保存しました');
        this.closeCardEdit();
        this.renderCardList();
      })
      .withFailureHandler(e => {
        console.error('Failed to save card:', e);
        alert('保存に失敗しました: ' + e.message);
      })
      .saveCardData(rowNumber, updatedFields, prog);
  },

  // 連続再生
  toggleAutoPlay: function() {
    AppState.study.isAutoPlay = !AppState.study.isAutoPlay;
    this.updateAutoPlayButton();
    if (AppState.study.isAutoPlay) this.startAutoPlay(); else Speech.stop();
  },

  toggleRepeat: function() { AppState.study.isRepeat = !AppState.study.isRepeat; this.updateRepeatButton(); },

  updateAutoPlayButton: function() {
    const btn = document.getElementById('btn-autoplay');
    if (btn) { btn.classList.toggle('autoplay-active', AppState.study.isAutoPlay); btn.querySelector('.material-icons').textContent = AppState.study.isAutoPlay ? 'pause_circle' : 'play_circle'; }
  },

  updateRepeatButton: function() {
    const btn = document.getElementById('btn-repeat');
    if (btn) btn.classList.toggle('repeat-active', AppState.study.isRepeat);
  },

  startAutoPlay: function() {
    if (!AppState.study.isAutoPlay) return;
    this.speakCurrentSide(() => {
      if (!AppState.study.isAutoPlay) return;
      const wait = Utils.getSettingNumber('waitTimeAfterFlip', 0) * 1000;
      setTimeout(() => {
        if (!AppState.study.isAutoPlay) return;
        if (!AppState.study.isFlipped) {
          this.flipCard();
          setTimeout(() => { if (AppState.study.isAutoPlay) this.startAutoPlay(); }, Math.max(0, wait));
        } else { this.autoPlayNextCard(); }
      }, Math.max(0, wait));
    });
  },

  autoPlayNextCard: function() {
    const wait = Utils.getSettingNumber('waitTimeBetweenCards', 0) * 1000;
    if (AppState.study.currentIndex < AppState.study.cards.length - 1) {
      this.slideToCardForAutoPlay(AppState.study.currentIndex + 1, 'next', () => { setTimeout(() => { if (AppState.study.isAutoPlay) this.startAutoPlay(); }, Math.max(0, wait)); });
    } else if (AppState.study.isRepeat) {
      this.slideToCardForAutoPlay(0, 'next', () => { setTimeout(() => { if (AppState.study.isAutoPlay) this.startAutoPlay(); }, Math.max(0, wait)); });
    } else { AppState.study.isAutoPlay = false; this.updateAutoPlayButton(); this.finishStudy(); }
  },

  slideToCardForAutoPlay: function(newIndex, direction, onComplete) {
    const flashcard = document.getElementById('flashcard');
    const inner = flashcard.querySelector('.flashcard-inner');
    CardRenderer.renderNext(AppState.study.cards[newIndex]);
    flashcard.classList.add(direction === 'next' ? 'slide-out-left' : 'slide-out-right');
    setTimeout(() => {
      AppState.study.currentIndex = newIndex;
      flashcard.style.transition = 'none'; inner.style.transition = 'none';
      flashcard.classList.remove('slide-out-left', 'slide-out-right', 'flipped');
      AppState.study.isFlipped = false;
      this.updateCardContent();
      flashcard.offsetHeight;
      flashcard.style.transition = ''; inner.style.transition = '';
      this.prepareNextCard();
      this.updateStudyProgress();
      if (onComplete) onComplete();
    }, ANIMATION_DURATION.SLIDE);
  },

  // 読み上げ
  speakCurrentCard: function() { if (AppState.study.isSpeaking) { Speech.stop(); return; } this.speakCurrentSide(); },

  speakCurrentSide: function(onComplete) {
    const card = AppState.study.cards[AppState.study.currentIndex];
    if (!card) { if (onComplete) onComplete(); return; }
    const side = AppState.study.isFlipped ? '裏' : '表';
    const fields = AppState.fields.filter(f => f.displaySide === side && f.speechOrder && f.speechOrder !== '-' && f.speechOrder !== '')
      .sort((a, b) => (parseInt(a.speechOrder) || 99) - (parseInt(b.speechOrder) || 99));
    if (fields.length === 0) { if (onComplete) onComplete(); return; }
    const items = fields.map(f => ({ text: card.fields[f.name] || '', lang: Speech.detectLanguage(f.name, card.fields[f.name]) })).filter(i => i.text);
    if (items.length === 0) { if (onComplete) onComplete(); return; }
    Speech.speakSequence(items, 0, onComplete);
  },

  setSpeakingState: function(isSpeaking) {
    AppState.study.isSpeaking = isSpeaking;
    const btn = document.getElementById('btn-speech');
    if (btn) { btn.classList.toggle('speaking', isSpeaking); btn.querySelector('.material-icons').textContent = isSpeaking ? 'stop' : 'volume_up'; }
  },

  stopSpeech: function() { Speech.stop(); },

  // 設定画面
  showSettings: function() { this.showScreen('settings-screen'); this.renderSettingsScreen(); },

  renderSettingsScreen: function() {
    const stats = Stats.calculate();
    const container = document.getElementById('settings-content');
    if (!container) return;
    
    const speechRateEn = Utils.getSettingNumber('speechRateEn', 1.0);
    const speechRateJa = Utils.getSettingNumber('speechRateJa', 1.0);
    const listSpeechRateEn = Utils.getSettingNumber('listSpeechRateEn', 1.0);
    const listSpeechRateJa = Utils.getSettingNumber('listSpeechRateJa', 1.0);
    const waitTimeAfterFlip = Utils.getSettingNumber('waitTimeAfterFlip', 0);
    const waitTimeBetweenCards = Utils.getSettingNumber('waitTimeBetweenCards', 0);
    
    container.innerHTML = '<div class="setting-section"><h3>学習統計</h3><div class="stats-detail">' +
      '<div class="stat-row"><span>総カード数</span><span>' + stats.total + '枚</span></div>' +
      '<div class="stat-row"><span>学習済み</span><span>' + stats.studied + '枚</span></div>' +
      '<div class="stat-row"><span>合格</span><span>' + stats.passed + '枚</span></div>' +
      '<div class="stat-row"><span>復習待ち</span><span>' + stats.review + '枚</span></div>' +
      '<div class="stat-row"><span>総正解数</span><span>' + stats.totalCorrect + '回</span></div>' +
      '<div class="stat-row"><span>総不正解数</span><span>' + stats.totalIncorrect + '回</span></div>' +
      '<div class="stat-row"><span>今日の学習</span><span>' + AppState.todayStudyCount + '枚</span></div>' +
      '<div class="stat-row highlight"><span>正解率</span><span>' + stats.accuracy + '%</span></div></div></div>' +
      '<div class="setting-section"><h3><span class="material-icons" style="vertical-align:middle;margin-right:4px;">record_voice_over</span>学習中の読み上げ速度</h3>' +
      '<div class="setting-slider-row"><label>英語</label><input type="range" id="setting-speech-en" min="0.5" max="2" step="0.1" value="' + speechRateEn + '"><span id="setting-speech-en-val">' + speechRateEn + 'x</span></div>' +
      '<div class="setting-slider-row"><label>日本語</label><input type="range" id="setting-speech-ja" min="0.5" max="2" step="0.1" value="' + speechRateJa + '"><span id="setting-speech-ja-val">' + speechRateJa + 'x</span></div></div>' +
      '<div class="setting-section"><h3><span class="material-icons" style="vertical-align:middle;margin-right:4px;">list_alt</span>一覧表示の読み上げ速度</h3>' +
      '<div class="setting-slider-row"><label>英語</label><input type="range" id="setting-list-speech-en" min="0.5" max="2" step="0.1" value="' + listSpeechRateEn + '"><span id="setting-list-speech-en-val">' + listSpeechRateEn + 'x</span></div>' +
      '<div class="setting-slider-row"><label>日本語</label><input type="range" id="setting-list-speech-ja" min="0.5" max="2" step="0.1" value="' + listSpeechRateJa + '"><span id="setting-list-speech-ja-val">' + listSpeechRateJa + 'x</span></div></div>' +
      '<div class="setting-section"><h3><span class="material-icons" style="vertical-align:middle;margin-right:4px;">timer</span>待機時間</h3>' +
      '<div class="setting-slider-row"><label>めくり後</label><input type="range" id="setting-wait-flip" min="0" max="5" step="0.5" value="' + waitTimeAfterFlip + '"><span id="setting-wait-flip-val">' + waitTimeAfterFlip + '秒</span></div>' +
      '<div class="setting-slider-row"><label>カード間</label><input type="range" id="setting-wait-card" min="0" max="5" step="0.5" value="' + waitTimeBetweenCards + '"><span id="setting-wait-card-val">' + waitTimeBetweenCards + '秒</span></div></div>' +
      '<div class="setting-section"><h3><span class="material-icons" style="vertical-align:middle;margin-right:4px;">link</span>データ管理</h3>' +
      '<a href="' + SPREADSHEET_URL + '" target="_blank" class="spreadsheet-link"><span class="material-icons">open_in_new</span>スプレッドシートを開く</a>' +
      '<p class="setting-hint">カードデータや詳細設定はスプレッドシートで編集できます。</p></div>';
    
    this.setupSettingsListeners();
  },

  setupSettingsListeners: function() {
    const self = this;
    // 読み上げ速度（英語）
    document.getElementById('setting-speech-en').addEventListener('input', function() {
      const val = parseFloat(this.value);
      document.getElementById('setting-speech-en-val').textContent = val + 'x';
      AppState.settings.speechRateEn = val;
    });
    // 読み上げ速度（日本語）
    document.getElementById('setting-speech-ja').addEventListener('input', function() {
      const val = parseFloat(this.value);
      document.getElementById('setting-speech-ja-val').textContent = val + 'x';
      AppState.settings.speechRateJa = val;
    });
    // 一覧表示の読み上げ速度（英語）
    document.getElementById('setting-list-speech-en').addEventListener('input', function() {
      const val = parseFloat(this.value);
      document.getElementById('setting-list-speech-en-val').textContent = val + 'x';
      AppState.settings.listSpeechRateEn = val;
    });
    // 一覧表示の読み上げ速度（日本語）
    document.getElementById('setting-list-speech-ja').addEventListener('input', function() {
      const val = parseFloat(this.value);
      document.getElementById('setting-list-speech-ja-val').textContent = val + 'x';
      AppState.settings.listSpeechRateJa = val;
    });
    // 待機時間（めくり後）
    document.getElementById('setting-wait-flip').addEventListener('input', function() {
      const val = parseFloat(this.value);
      document.getElementById('setting-wait-flip-val').textContent = val + '秒';
      AppState.settings.waitTimeAfterFlip = val;
    });
    // 待機時間（カード間）
    document.getElementById('setting-wait-card').addEventListener('input', function() {
      const val = parseFloat(this.value);
      document.getElementById('setting-wait-card-val').textContent = val + '秒';
      AppState.settings.waitTimeBetweenCards = val;
    });
  },

  closeSettings: function() { this.showScreen('home-screen'); }
};

document.addEventListener('DOMContentLoaded', function() { App.init(); });
</script>
