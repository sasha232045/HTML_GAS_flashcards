<script>
/**
 * GAS フラッシュカード - クライアントサイドJavaScript
 * ステップ1: 基本構造 + スプレッドシート接続
 */

// ============================================
// グローバル状態
// ============================================
const AppState = {
  fields: [],
  cards: [],
  progress: {},
  settings: {},
  decks: { tree: {}, list: [] },
  isLoading: true,
  error: null,
  
  // 学習状態（ステップ2追加）
  study: {
    mode: null,           // 'review', 'new', 'all'
    cards: [],            // 学習対象カード
    currentIndex: 0,      // 現在のカードインデックス
    isFlipped: false,     // カードがめくられているか
    sessionAnswers: {}    // 今回のセッションでの回答状態 {rowNumber: 'correct'|'incorrect'|null}
  },
  
  // デッキ選択状態（ステップ3追加）
  selectedDeck: null,      // 選択中のデッキパス（nullは全デッキ）
  
  // 学習設定（ステップ4追加）
  studySettings: {
    mode: 'all',           // 'all', 'review', 'new'
    rangeStart: null,      // 開始行番号
    rangeEnd: null,        // 終了行番号
    filterFavorite: false, // お気に入りのみ
    filterNotPassed: false,// 未合格のみ
    shuffle: true          // シャッフル
  }
};

// ============================================
// アプリケーションメイン
// ============================================
const App = {
  /**
   * 初期化
   */
  init: function() {
    console.log('App initializing...');
    this.loadInitialData();
  },

  /**
   * 初期データを読み込み
   */
  loadInitialData: function() {
    this.showScreen('loading-screen');
    
    google.script.run
      .withSuccessHandler(this.onDataLoaded.bind(this))
      .withFailureHandler(this.onDataError.bind(this))
      .getInitialData();
  },

  /**
   * データ読み込み成功時
   */
  onDataLoaded: function(data) {
    try {
      console.log('=== onDataLoaded START ===');
      console.log('Data loaded:', data);
      
      console.log('Setting AppState...');
      AppState.fields = data.fields || [];
      AppState.cards = data.cards || [];
      AppState.progress = data.progress || {};
      AppState.settings = data.settings || {};
      AppState.decks = data.decks || { tree: {}, list: [] };
      AppState.isLoading = false;
      console.log('AppState set successfully');
      
      console.log('Calling updateStats...');
      this.updateStats();
      console.log('updateStats completed');
      
      console.log('Calling updateDebugInfo...');
      this.updateDebugInfo();
      console.log('updateDebugInfo completed');
      
      // ローディング画面を確実に非表示にしてからホーム画面を表示
      console.log('Hiding loading screen...');
      const loadingScreen = document.getElementById('loading-screen');
      console.log('loadingScreen element:', loadingScreen);
      if (loadingScreen) {
        loadingScreen.style.display = 'none';
        loadingScreen.classList.remove('active');
        console.log('Loading screen hidden');
      }
      
      console.log('Calling showScreen(home-screen)...');
      this.showScreen('home-screen');
      console.log('=== onDataLoaded END ===');
    } catch (error) {
      console.error('=== ERROR in onDataLoaded ===');
      console.error('Error:', error);
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
    }
  },

  /**
   * データ読み込みエラー時
   */
  onDataError: function(error) {
    console.error('Data load error:', error);
    AppState.error = error;
    AppState.isLoading = false;
    
    document.getElementById('error-message').textContent = error.message || 'データの読み込みに失敗しました';
    this.showScreen('error-screen');
  },

  /**
   * 再試行
   */
  retry: function() {
    this.loadInitialData();
  },

  /**
   * 画面切り替え
   */
  showScreen: function(screenId) {
    console.log('Switching to screen:', screenId);
    
    // 全画面を非表示
    document.querySelectorAll('.screen').forEach(screen => {
      screen.classList.remove('active');
      screen.style.display = 'none';
    });
    
    // 対象画面を表示
    const targetScreen = document.getElementById(screenId);
    if (targetScreen) {
      targetScreen.classList.add('active');
      // ローディング画面はflexで表示
      if (screenId === 'loading-screen') {
        targetScreen.style.display = 'flex';
      } else {
        targetScreen.style.display = 'block';
      }
      console.log('Screen activated:', screenId);
    } else {
      console.error('Screen not found:', screenId);
    }
  },

  /**
   * 統計情報を更新
   */
  updateStats: function() {
    try {
      console.log('=== updateStats START ===');
      const cards = AppState.cards;
      const progress = AppState.progress;
      const today = new Date().toISOString().split('T')[0];
      console.log('Today:', today, 'Cards count:', cards.length);
      
      // 学習済みカード数
      let studiedCount = 0;
      let passedCount = 0;
      let reviewCount = 0;
      
      for (const card of cards) {
        const rowNum = card.rowNumber;
        const prog = progress[rowNum];
        
        if (prog) {
          if (prog.correctCount > 0 || prog.incorrectCount > 0) {
            studiedCount++;
          }
          if (prog.passed) {
            passedCount++;
          }
          if (prog.nextReviewDate && prog.nextReviewDate <= today && !prog.passed) {
            reviewCount++;
          }
        }
      }
      
      console.log('Stats calculated:', { studiedCount, passedCount, reviewCount });
      
      const statToday = document.getElementById('stat-today');
      const statTotal = document.getElementById('stat-total');
      const statPassed = document.getElementById('stat-passed');
      const statReview = document.getElementById('stat-review');
      
      console.log('Stat elements:', { statToday, statTotal, statPassed, statReview });
      
      if (statToday) statToday.textContent = '0';
      if (statTotal) statTotal.textContent = studiedCount + ' / ' + cards.length;
      if (statPassed) statPassed.textContent = passedCount;
      if (statReview) statReview.textContent = reviewCount;
      
      console.log('=== updateStats END ===');
    } catch (error) {
      console.error('=== ERROR in updateStats ===');
      console.error('Error:', error);
    }
  },

  /**
   * デバッグ情報を更新（ステップ1用）
   */
  updateDebugInfo: function() {
    try {
      console.log('=== updateDebugInfo START ===');
      
      const debugConnection = document.getElementById('debug-connection');
      const debugCardCount = document.getElementById('debug-card-count');
      const debugFieldCount = document.getElementById('debug-field-count');
      const debugDeckCount = document.getElementById('debug-deck-count');
      
      console.log('Debug elements:', { debugConnection, debugCardCount, debugFieldCount, debugDeckCount });
      
      if (debugConnection) {
        debugConnection.textContent = '✓ 接続成功';
        debugConnection.style.color = 'green';
      }
      if (debugCardCount) debugCardCount.textContent = AppState.cards.length;
      if (debugFieldCount) debugFieldCount.textContent = AppState.fields.length;
      if (debugDeckCount) debugDeckCount.textContent = AppState.decks.list.length;
      
      console.log('=== updateDebugInfo END ===');
    } catch (error) {
      console.error('=== ERROR in updateDebugInfo ===');
      console.error('Error:', error);
    }
  },

  /**
   * 生データを表示（ステップ1用）
   */
  showRawData: function() {
    const rawDataEl = document.getElementById('debug-raw-data');
    if (rawDataEl.classList.contains('show')) {
      rawDataEl.classList.remove('show');
    } else {
      rawDataEl.textContent = JSON.stringify({
        fields: AppState.fields,
        cards: AppState.cards,
        progress: AppState.progress,
        settings: AppState.settings,
        decks: AppState.decks
      }, null, 2);
      rawDataEl.classList.add('show');
    }
  },

  /**
   * 学習開始
   */
  startStudy: function(mode) {
    console.log('Starting study mode:', mode);
    
    // 学習対象カードを取得
    let studyCards = [];
    const today = new Date().toISOString().split('T')[0];
    
    switch (mode) {
      case 'review':
        // 今日の復習: 次回復習日が今日以前のカード
        studyCards = AppState.cards.filter(card => {
          const prog = AppState.progress[card.rowNumber];
          if (!prog) return false;
          return prog.nextReviewDate && prog.nextReviewDate <= today && !prog.passed;
        });
        break;
      case 'new':
        // 新規学習: まだ学習していないカード
        studyCards = AppState.cards.filter(card => {
          const prog = AppState.progress[card.rowNumber];
          return !prog || (prog.correctCount === 0 && prog.incorrectCount === 0);
        });
        break;
      case 'all':
        // 全体復習: 全カード
        studyCards = [...AppState.cards];
        break;
    }
    
    if (studyCards.length === 0) {
      alert('学習するカードがありません');
      return;
    }
    
    // シャッフル（設定に応じて）
    if (AppState.settings.shuffleCards !== false) {
      studyCards = this.shuffleArray(studyCards);
    }
    
    // 学習状態を初期化
    AppState.study.mode = mode;
    AppState.study.cards = studyCards;
    AppState.study.currentIndex = 0;
    AppState.study.isFlipped = false;
    AppState.study.sessionAnswers = {}; // セッション回答を初期化
    
    // 学習画面を表示
    this.showScreen('study-screen');
    this.renderCard();
    this.updateStudyProgress();
  },

  /**
   * 配列をシャッフル
   */
  shuffleArray: function(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  },

  /**
   * カードを表示
   */
  renderCard: function() {
    const card = AppState.study.cards[AppState.study.currentIndex];
    if (!card) return;
    
    console.log('Rendering card:', card);
    
    // フィールド情報を取得
    const fields = AppState.fields;
    
    // 表面のコンテンツを生成
    const frontFields = fields
      .filter(f => f.displaySide === '表')
      .sort((a, b) => (parseInt(a.displayOrder) || 99) - (parseInt(b.displayOrder) || 99));
    
    // 裏面のコンテンツを生成
    const backFields = fields
      .filter(f => f.displaySide === '裏')
      .sort((a, b) => (parseInt(a.displayOrder) || 99) - (parseInt(b.displayOrder) || 99));
    
    // 表面を描画
    const frontContent = document.getElementById('front-content');
    frontContent.innerHTML = frontFields.map((field, index) => {
      const value = card.fields[field.name] || '';
      const isFirst = index === 0;
      return '<div class="card-field">' +
        '<div class="card-field-label">' + this.escapeHtml(field.name) + '</div>' +
        '<div class="card-field-value' + (isFirst ? ' large' : '') + '">' + this.escapeHtml(value) + '</div>' +
      '</div>';
    }).join('');
    
    // 裏面を描画
    const backContent = document.getElementById('back-content');
    backContent.innerHTML = backFields.map((field, index) => {
      const value = card.fields[field.name] || '';
      const isFirst = index === 0;
      return '<div class="card-field">' +
        '<div class="card-field-label">' + this.escapeHtml(field.name) + '</div>' +
        '<div class="card-field-value' + (isFirst ? ' large' : '') + '">' + this.escapeHtml(value) + '</div>' +
      '</div>';
    }).join('');
    
    // カードを表面にリセット
    const flashcard = document.getElementById('flashcard');
    flashcard.classList.remove('flipped');
    AppState.study.isFlipped = false;
    
    // 回答ボタンを非表示
    document.getElementById('answer-buttons').style.display = 'none';
    
    // お気に入り・合格状態を更新
    this.updateCardButtons(card);
    
    // ナビゲーションボタンの状態を更新
    this.updateNavButtons();
  },

  /**
   * HTMLエスケープ
   */
  escapeHtml: function(str) {
    if (str === null || str === undefined) return '';
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  },

  /**
   * カードをめくる
   */
  flipCard: function() {
    const flashcard = document.getElementById('flashcard');
    
    if (AppState.study.isFlipped) {
      flashcard.classList.remove('flipped');
      AppState.study.isFlipped = false;
      document.getElementById('answer-buttons').style.display = 'none';
    } else {
      flashcard.classList.add('flipped');
      AppState.study.isFlipped = true;
      document.getElementById('answer-buttons').style.display = 'flex';
    }
  },

  /**
   * 学習進捗を更新
   */
  updateStudyProgress: function() {
    document.getElementById('study-current').textContent = AppState.study.currentIndex + 1;
    document.getElementById('study-total').textContent = AppState.study.cards.length;
  },

  /**
   * カードのお気に入り・合格ボタンを更新
   */
  updateCardButtons: function(card) {
    const prog = AppState.progress[card.rowNumber] || {};
    
    const btnFavorite = document.getElementById('btn-favorite');
    const btnPassed = document.getElementById('btn-passed');
    
    // お気に入り
    if (prog.favorite) {
      btnFavorite.classList.add('active');
      btnFavorite.querySelector('.material-icons').textContent = 'star';
    } else {
      btnFavorite.classList.remove('active');
      btnFavorite.querySelector('.material-icons').textContent = 'star_border';
    }
    
    // 合格
    if (prog.passed) {
      btnPassed.classList.add('passed');
      btnPassed.querySelector('.material-icons').textContent = 'check_circle';
    } else {
      btnPassed.classList.remove('passed');
      btnPassed.querySelector('.material-icons').textContent = 'check_circle_outline';
    }
  },

  /**
   * ナビゲーションボタンの状態を更新
   */
  updateNavButtons: function() {
    const btnPrev = document.getElementById('btn-prev');
    const btnNext = document.getElementById('btn-next');
    
    btnPrev.disabled = AppState.study.currentIndex === 0;
    btnNext.disabled = AppState.study.currentIndex >= AppState.study.cards.length - 1;
  },

  /**
   * 前のカードへ
   */
  prevCard: function() {
    if (AppState.study.currentIndex > 0) {
      AppState.study.currentIndex--;
      this.renderCard();
      this.updateStudyProgress();
    }
  },

  /**
   * 次のカードへ
   */
  nextCard: function() {
    if (AppState.study.currentIndex < AppState.study.cards.length - 1) {
      AppState.study.currentIndex++;
      this.renderCard();
      this.updateStudyProgress();
    } else {
      // 学習完了
      this.finishStudy();
    }
  },

  /**
   * 回答を記録
   */
  answerCard: function(isCorrect) {
    console.log('Answer:', isCorrect ? 'Correct' : 'Incorrect');
    
    const card = AppState.study.cards[AppState.study.currentIndex];
    const rowNumber = card.rowNumber;
    
    // 進捗データを取得または初期化
    let prog = AppState.progress[rowNumber] || {
      correctCount: 0,
      incorrectCount: 0,
      streak: 0,
      nextReviewDate: null,
      favorite: false,
      passed: false
    };
    
    // 前回の回答を取得（このセッション内での回答）
    const previousAnswer = AppState.study.sessionAnswers[rowNumber];
    
    // 前回回答済みの場合、まず前回の回答を取り消す
    if (previousAnswer !== undefined && previousAnswer !== null) {
      if (previousAnswer === 'correct') {
        prog.correctCount = Math.max(0, prog.correctCount - 1);
        prog.streak = Math.max(0, prog.streak - 1);
      } else if (previousAnswer === 'incorrect') {
        prog.incorrectCount = Math.max(0, prog.incorrectCount - 1);
        // 不正解後の連続は0になっていたので、復元は複雑
        // ここでは単純に不正解数を減らすのみ
      }
      console.log('Previous answer cancelled:', previousAnswer);
    }
    
    // 新しい回答を記録
    if (isCorrect) {
      prog.correctCount++;
      prog.streak++;
    } else {
      prog.incorrectCount++;
      prog.streak = 0; // 不正解で連続リセット
    }
    
    // セッション回答を記録
    AppState.study.sessionAnswers[rowNumber] = isCorrect ? 'correct' : 'incorrect';
    
    // 次回復習日を計算（スペースドリピティション）
    prog.nextReviewDate = this.calculateNextReviewDate(prog.streak);
    
    // AppStateを更新
    AppState.progress[rowNumber] = prog;
    
    // サーバーに保存
    this.saveProgressToServer(rowNumber, prog);
    
    // 視覚的フィードバック
    const flashcard = document.getElementById('flashcard');
    const animClass = isCorrect ? 'answer-correct' : 'answer-incorrect';
    flashcard.classList.add(animClass);
    
    // アニメーション終了後に次のカードへ
    setTimeout(() => {
      flashcard.classList.remove(animClass);
      this.nextCard();
    }, 500);
  },

  /**
   * 次回復習日を計算（スペースドリピティション）
   */
  calculateNextReviewDate: function(streak) {
    const settings = AppState.settings;
    let interval = 1;
    
    if (streak >= 5) {
      interval = settings.interval_5 || 30;
    } else if (streak >= 4) {
      interval = settings.interval_4 || 14;
    } else if (streak >= 3) {
      interval = settings.interval_3 || 7;
    } else if (streak >= 2) {
      interval = settings.interval_2 || 3;
    } else if (streak >= 1) {
      interval = settings.interval_1 || 1;
    }
    
    const nextDate = new Date();
    nextDate.setDate(nextDate.getDate() + interval);
    
    return nextDate.toISOString().split('T')[0];
  },

  /**
   * 進捗をサーバーに保存
   */
  saveProgressToServer: function(rowNumber, progressData) {
    google.script.run
      .withSuccessHandler((result) => {
        console.log('Progress saved:', result);
      })
      .withFailureHandler((error) => {
        console.error('Failed to save progress:', error);
      })
      .saveProgress(rowNumber, progressData);
  },

  /**
   * お気に入り切替え
   */
  toggleFavorite: function() {
    const card = AppState.study.cards[AppState.study.currentIndex];
    const rowNumber = card.rowNumber;
    
    // 進捗データを取得または初期化
    let prog = AppState.progress[rowNumber] || {
      correctCount: 0,
      incorrectCount: 0,
      streak: 0,
      nextReviewDate: null,
      favorite: false,
      passed: false
    };
    
    prog.favorite = !prog.favorite;
    AppState.progress[rowNumber] = prog;
    this.updateCardButtons(card);
    console.log('Favorite toggled:', prog.favorite);
    
    // サーバーに保存
    this.saveProgressToServer(rowNumber, prog);
  },

  /**
   * 合格切替え
   */
  togglePassed: function() {
    const card = AppState.study.cards[AppState.study.currentIndex];
    const rowNumber = card.rowNumber;
    
    // 進捗データを取得または初期化
    let prog = AppState.progress[rowNumber] || {
      correctCount: 0,
      incorrectCount: 0,
      streak: 0,
      nextReviewDate: null,
      favorite: false,
      passed: false
    };
    
    prog.passed = !prog.passed;
    AppState.progress[rowNumber] = prog;
    this.updateCardButtons(card);
    console.log('Passed toggled:', prog.passed);
    
    // サーバーに保存
    this.saveProgressToServer(rowNumber, prog);
  },

  /**
   * 学習終了
   */
  finishStudy: function() {
    alert('学習完了！');
    this.exitStudy();
  },

  /**
   * 学習を終了してホームに戻る
   */
  exitStudy: function() {
    AppState.study.mode = null;
    AppState.study.cards = [];
    AppState.study.currentIndex = 0;
    AppState.study.isFlipped = false;
    AppState.study.sessionAnswers = {}; // セッション回答をクリア
    
    this.updateStats();
    this.showScreen('home-screen');
  },

  /**
   * デッキ選択画面を表示
   */
  showDeckSelect: function() {
    this.renderDeckTree();
    this.updateSelectedDeckInfo();
    this.showScreen('deck-screen');
  },

  /**
   * デッキ選択画面を閉じる
   */
  closeDeckSelect: function() {
    this.showScreen('home-screen');
  },

  /**
   * デッキツリーを描画
   */
  renderDeckTree: function() {
    const container = document.getElementById('deck-tree');
    const decks = AppState.decks;
    
    let html = '';
    
    // 「すべてのデッキ」オプション
    const allSelected = AppState.selectedDeck === null;
    html += '<div class="deck-item deck-all-item' + (allSelected ? ' selected' : '') + '" onclick="App.selectDeck(null)">';
    html += '<span class="material-icons">folder_special</span>';
    html += '<span class="deck-item-name">すべてのデッキ</span>';
    html += '<span class="deck-item-count">' + AppState.cards.length + '枚</span>';
    html += '</div>';
    
    // デッキツリーを再帰的に描画
    html += this.renderDeckTreeNode(decks.tree, '');
    
    container.innerHTML = html;
  },

  /**
   * デッキツリーノードを再帰的に描画
   */
  renderDeckTreeNode: function(node, parentPath) {
    let html = '';
    
    for (const key in node) {
      if (key === '_path' || key === '_children') continue;
      
      const deckData = node[key];
      const path = parentPath ? parentPath + '/' + key : key;
      const children = deckData._children || {};
      const hasChildren = Object.keys(children).filter(k => k !== '_path' && k !== '_children').length > 0;
      const cardCount = this.getCardCountForDeck(path);
      const isSelected = AppState.selectedDeck === path;
      
      html += '<div class="deck-node">';
      html += '<div class="deck-item' + (isSelected ? ' selected' : '') + '" onclick="App.selectDeck(\'' + this.escapeHtml(path) + '\')">';
      
      if (hasChildren) {
        html += '<button class="deck-toggle" onclick="event.stopPropagation(); App.toggleDeckNode(this)">';
        html += '<span class="material-icons">chevron_right</span>';
        html += '</button>';
      } else {
        html += '<span style="width: 28px; display: inline-block;"></span>';
      }
      
      html += '<span class="material-icons">folder</span>';
      html += '<span class="deck-item-name">' + this.escapeHtml(key) + '</span>';
      html += '<span class="deck-item-count">' + cardCount + '枚</span>';
      html += '</div>';
      
      if (hasChildren) {
        html += '<div class="deck-children" style="display: none;">';
        html += this.renderDeckTreeNode(children, path);
        html += '</div>';
      }
      
      html += '</div>';
    }
    
    return html;
  },

  /**
   * デッキに含まれるカード数を取得
   */
  getCardCountForDeck: function(deckPath) {
    return AppState.cards.filter(card => {
      const cardDeck = card.fields['デッキ'] || '';
      // 完全一致または子デッキ
      return cardDeck === deckPath || cardDeck.startsWith(deckPath + '/');
    }).length;
  },

  /**
   * デッキノードの展開/折りたたみ
   */
  toggleDeckNode: function(button) {
    const deckNode = button.closest('.deck-node');
    const children = deckNode.querySelector('.deck-children');
    
    if (children) {
      const isHidden = children.style.display === 'none';
      children.style.display = isHidden ? 'block' : 'none';
      button.classList.toggle('expanded', isHidden);
    }
  },

  /**
   * デッキを選択
   */
  selectDeck: function(deckPath) {
    AppState.selectedDeck = deckPath;
    this.renderDeckTree();
    this.updateSelectedDeckInfo();
  },

  /**
   * 選択中のデッキ情報を更新
   */
  updateSelectedDeckInfo: function() {
    const nameEl = document.getElementById('selected-deck-name');
    const countEl = document.getElementById('selected-deck-count');
    
    if (AppState.selectedDeck === null) {
      nameEl.textContent = 'すべてのデッキ';
      countEl.textContent = AppState.cards.length + '枚';
    } else {
      nameEl.textContent = AppState.selectedDeck;
      countEl.textContent = this.getCardCountForDeck(AppState.selectedDeck) + '枚';
    }
  },

  /**
   * 学習設定画面を表示
   */
  showStudySettings: function() {
    // 設定画面のデッキ名を更新
    const deckName = AppState.selectedDeck || 'すべてのデッキ';
    document.getElementById('settings-deck-name').textContent = deckName;
    
    // 入力欄をリセット
    document.getElementById('word-start').value = '';
    document.getElementById('word-count').value = '';
    document.getElementById('filter-favorite').checked = false;
    document.getElementById('filter-not-passed').checked = false;
    document.getElementById('setting-shuffle').checked = true;
    document.querySelector('input[name="studyMode"][value="all"]').checked = true;
    
    // イベントリスナーを設定
    this.setupStudySettingsListeners();
    
    // プレビューを更新
    this.updateFilteredCardCount();
    
    this.showScreen('study-settings-screen');
  },

  /**
   * 学習設定画面のイベントリスナーを設定
   */
  setupStudySettingsListeners: function() {
    const self = this;
    const inputs = [
      'word-start', 'word-count', 'filter-favorite', 
      'filter-not-passed', 'setting-shuffle'
    ];
    
    inputs.forEach(id => {
      const el = document.getElementById(id);
      el.removeEventListener('change', self.updateFilteredCardCount.bind(self));
      el.addEventListener('change', self.updateFilteredCardCount.bind(self));
      if (el.type === 'number') {
        el.removeEventListener('input', self.updateFilteredCardCount.bind(self));
        el.addEventListener('input', self.updateFilteredCardCount.bind(self));
      }
    });
    
    // ラジオボタン
    document.querySelectorAll('input[name="studyMode"]').forEach(radio => {
      radio.removeEventListener('change', self.updateFilteredCardCount.bind(self));
      radio.addEventListener('change', self.updateFilteredCardCount.bind(self));
    });
  },

  /**
   * 絞り込み結果のカード数を更新
   */
  updateFilteredCardCount: function() {
    const cards = this.getFilteredCards();
    document.getElementById('filtered-card-count').textContent = cards.length;
  },

  /**
   * 現在の設定でフィルターされたカードを取得
   */
  getFilteredCards: function() {
    const mode = document.querySelector('input[name="studyMode"]:checked').value;
    const wordStart = parseInt(document.getElementById('word-start').value) || null;
    const wordCount = parseInt(document.getElementById('word-count').value) || null;
    const filterFavorite = document.getElementById('filter-favorite').checked;
    const filterNotPassed = document.getElementById('filter-not-passed').checked;
    
    const today = new Date().toISOString().split('T')[0];
    
    let cards = [...AppState.cards];
    
    // デッキフィルター
    if (AppState.selectedDeck !== null) {
      cards = cards.filter(card => {
        const cardDeck = card.fields['デッキ'] || '';
        return cardDeck === AppState.selectedDeck || cardDeck.startsWith(AppState.selectedDeck + '/');
      });
    }
    
    // 単語番号でソート（行番号順）
    cards.sort((a, b) => a.rowNumber - b.rowNumber);
    
    // 単語番号フィルター（単語番号1 = 行番号5）
    // wordStart: 開始単語番号（1から始まる）
    // wordCount: 学習する単語数
    if (wordStart !== null && wordStart >= 1) {
      // 開始単語番号のインデックスを計算（0始まり）
      const startIndex = wordStart - 1;
      
      if (wordCount !== null && wordCount >= 1) {
        // 開始位置から指定数だけ取得
        cards = cards.slice(startIndex, startIndex + wordCount);
      } else {
        // 開始位置から最後まで
        cards = cards.slice(startIndex);
      }
    } else if (wordCount !== null && wordCount >= 1) {
      // 開始位置未指定で数だけ指定：最初から指定数
      cards = cards.slice(0, wordCount);
    }
    
    // 学習モードフィルター
    if (mode === 'review') {
      cards = cards.filter(card => {
        const prog = AppState.progress[card.rowNumber];
        if (!prog) return false;
        return prog.nextReviewDate && prog.nextReviewDate <= today && !prog.passed;
      });
    } else if (mode === 'new') {
      cards = cards.filter(card => {
        const prog = AppState.progress[card.rowNumber];
        return !prog || (prog.correctCount === 0 && prog.incorrectCount === 0);
      });
    }
    
    // お気に入りフィルター
    if (filterFavorite) {
      cards = cards.filter(card => {
        const prog = AppState.progress[card.rowNumber];
        return prog && prog.favorite;
      });
    }
    
    // 未合格フィルター
    if (filterNotPassed) {
      cards = cards.filter(card => {
        const prog = AppState.progress[card.rowNumber];
        return !prog || !prog.passed;
      });
    }
    
    return cards;
  },

  /**
   * 学習設定画面を閉じる
   */
  closeStudySettings: function() {
    this.showScreen('deck-screen');
  },

  /**
   * 絞り込みで学習開始
   */
  startFilteredStudy: function() {
    const shuffle = document.getElementById('setting-shuffle').checked;
    let studyCards = this.getFilteredCards();
    
    if (studyCards.length === 0) {
      alert('条件に一致するカードがありません');
      return;
    }
    
    // シャッフル
    if (shuffle) {
      studyCards = this.shuffleArray(studyCards);
    }
    
    // 学習状態を初期化
    AppState.study.mode = 'filtered';
    AppState.study.cards = studyCards;
    AppState.study.currentIndex = 0;
    AppState.study.isFlipped = false;
    AppState.study.sessionAnswers = {}; // セッション回答を初期化
    
    // 学習画面を表示
    this.showScreen('study-screen');
    this.renderCard();
    this.updateStudyProgress();
  },

  /**
   * 設定画面（ステップ10で実装）
   */
  showSettings: function() {
    alert('設定画面\n（ステップ10で実装）');
  }
};

// ============================================
// DOM読み込み完了時に初期化
// ============================================
document.addEventListener('DOMContentLoaded', function() {
  App.init();
});
</script>
